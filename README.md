# PureConfig

A boilerplate-free Scala library for loading configuration files.

[![Build Status](https://travis-ci.org/melrief/pureconfig.svg?branch=master)](https://travis-ci.org/melrief/pureconfig)
[![Maven Central](https://maven-badges.herokuapp.com/maven-central/com.github.melrief/pureconfig_2.11/badge.svg)](https://maven-badges.herokuapp.com/maven-central/com.github.melrief/pureconfig_2.11)
[![Join the chat at https://gitter.im/melrief/pureconfig](https://badges.gitter.im/melrief/pureconfig.svg)](https://gitter.im/melrief/pureconfig?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)

![](http://i.imgur.com/S5QUS8c.gif)


## Table of Contents

- [Why](#why)
- [Not Yet Another Configuration Library](#not-yet-another-configuration-library)
- [Add PureConfig to your project](#add-pureconfig-to-your-project)
- [Use PureConfig](#use-pureconfig)
- [Supported types](#supported-types)
- [Configurable converters](#configurable-converters)
- [Extend the library to support new types](#extend-the-library-to-support-new-types)
- [Override behaviour for types](#override-behaviour-for-types)
- [Override behaviour for case classes](#override-behaviour-for-case-classes)
  - [Field mappings](#field-mappings)
  - [Default field values](#default-field-values)
  - [Unknown keys](#unknown-keys)
- [Override behaviour for sealed families](#override-behaviour-for-sealed-families)
- [Handling missing keys](#handling-missing-keys)
- [Example](#example)
- [Whence the config files](#whence-the-config-files)
- [Contribute](#contribute)
- [License](#license)
- [Special thanks](#special-thanks)


## Why

Loading configurations has always been a tedious and error-prone procedure. A common way to do it
consists in writing code to deserialize each fields of the configuration. The more fields there are,
the more code must be written (and tested and maintained...) and this must be replicated for each project.

This kind of code is boilerplate because most of the times the code can be automatically generated by
the compiler based on what must be loaded. For instance, if you are going to load an `Int` for a field
named `foo`, then probably you want some code that gets the values associated with the key `foo` in
the configuration and assigns it to the proper field after converting it to `Int`.

The goal of this library is to create at compile-time the boilerplate necessary to load a configuration of a
certain type. In other words, you define **what** to load and PureConfig provides **how** to load it.


## Not yet another configuration library

PureConfig is not a configuration library in the sense that it doesn't search for files or parse them.
It can be seen as a better front-end for the existing libraries.
It uses the [Typesafe Config][typesafe-config] library for loading raw configurations and then
uses the raw configurations to do its magic.


## Add PureConfig to your project

In the sbt configuration file use Scala `2.10`, `2.11` or `2.12`:

```scala
scalaVersion := "2.12.1" // or "2.11.8", "2.10.5"
```

Add PureConfig to your library dependencies. For Scala `2.11` and `2.12`:

```scala
libraryDependencies ++= Seq(
  "com.github.melrief" %% "pureconfig" % "0.5.1"
)
```

For Scala `2.10` you need also the Macro Paradise plugin:

```scala
libraryDependencies ++= Seq(
  "com.github.melrief" %% "pureconfig" % "0.5.1",
  compilerPlugin("org.scalamacros" % "paradise" % "2.0.1" cross CrossVersion.full)
)
```

For a full example of `build.sbt` you can have a look at this [build.sbt](https://github.com/melrief/pureconfig/blob/master/example/build.sbt)
used for the example.


## Use PureConfig

Import the library package and use one of the `loadConfig` methods:

```scala
import pureconfig._

val config: Try[YourConfClass] = loadConfig[YourConfClass]
```


## Supported Types

Currently supported types for fields are:
- `String`, `Boolean`, `Double` (standard
  and percentage format ending with `%`), `Float` (also supporting percentage),
  `Int`, `Long`, `Short`, `URL`, `Duration`, `FiniteDuration`;
- all collections implementing the `TraversableOnce` trait where the type of
  the elements is in this list;
- `Option` for optional values, i.e. values that can or cannot be in the configuration;
- `Map` with `String` keys and any value type that is in this list;
- everything in [`java.time`](https://docs.oracle.com/javase/8/docs/api/java/time/package-summary.html) (must be
  configured first - see [Configurable converters](#configurable-converters));
- Typesafe `ConfigValue`, `ConfigObject` and `ConfigList`;
- case classes;
- sealed families of case classes (ADTs).

An almost comprehensive example is:

```scala
import com.typesafe.config.ConfigFactory.parseString

sealed trait MyAdt
case class AdtA(a: String) extends MyAdt
case class AdtB(b: Int) extends MyAdt
case class MyClass(int: Int, adt: MyAdt, list: List[Double], map: Map[String, String], option: Option[String])

val conf = parseString("""{ "int": 1, "adt": { "type": "adtb", "b": 1 }, "list": ["1", "20%"], "map": { "key": "value" } }""")

loadConfig[MyClass](conf)
// returns Success(MyClass(1, AdtB(1), List(1.0, 0.2), Map("key" -> "value"), None))
```


## Configurable converters

For some types, PureConfig cannot automatically derive a converter because there are multiple ways to convert a configuration
value to them. For instance, for [`LocalDate`](https://docs.oracle.com/javase/8/docs/api/java/time/LocalDate.html)
PureConfig cannot derive a converter because there are multiple [`DateTimeFormatter`](https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html)s
that can be used to convert a String into a `LocalDate`. Examples of different formats are `yyyy-mm-dd`, e.g. `"2016-01-01"`,
and `yyyymmdd`, e.g. `"20160101"`. For those types, PureConfig provides a way to create converters from the necessary parameters. These methods can be found under
the package `pureconfig.configurable`. Once the output of a `pureconfig.configurable` method for a certain type is in scope,
PureConfig can start using that configured converter:

```scala
import java.time.LocalDate
import java.time.format.DateTimeFormatter
import pureconfig.configurable._

case class Conf(date: LocalDate)

implicit val localDateInstance = localDateConfigConvert(DateTimeFormatter.ISO_DATE)

val conf = parseString(s"""{ date: "2011-12-03" }""")

loadConfig[Conf](conf)
// returns Success(Conf(LocalDate.parse("2011-12-03", DateTimeFormatter.ISO_DATE)))
```


## Extend the library to support new types

Not all types are supported automatically by PureConfig. For instance, classes
that are not case classes are not supported out-of-the-box:

```scala
class MyInt(var value: Int) {
  override def toString: String = s"MyInt($value)"
}

case class Conf(n: MyInt)

val conf = parseString(s"""{ n: 1 }""")

loadConfig[Conf](conf)
// doesn't compile - could not find implicit value for parameter conv: pureconfig.ConfigConvert[Conf]
```

PureConfig can be extended to support those types. To do so, an instance for the
`ConfigConvert` type class must be provided implicitly, like:

```scala
import scala.util.Try

implicit val myIntConvert = ConfigConvert.stringConvert[MyInt](s => Try(new MyInt(s.toInt)), n => n.value.toString)

loadConfig[Conf](conf)
// returns Success(Conf(new MyInt(1)))
```


## Override behaviour for types

It is possible to override the behaviour of PureConfig for a certain type by
implementing another instance of the `ConfigConvert` type class. For instance,
the default behaviour of PureConfig for `String` is to return the string itself
in the configuration:

```scala
import com.typesafe.config.ConfigValueFactory

ConfigConvert[String].from(ConfigValueFactory.fromAnyRef("FooBar"))
// returns Success("FooBar")
```

Now let's say that we want to override this behaviour such that `String`s are
always read lower case. We can do:

```scala
implicit val overrideStrConvert = ConfigConvert.fromString(s => Try(s.toLowerCase))

ConfigConvert[String].from(ConfigValueFactory.fromAnyRef("FooBar"))
// returns Success("foobar")
```


## Override behaviour for case classes

PureConfig has to assume some conventions and behaviours when deriving
`ConfigConvert` instances for case classes:

- How do keys in config objects map to field names of the case class?
- Are unknown keys allowed in the config object?
- Should default values in case class fields be applied when its respective
  config key is missing?

By default, PureConfig:

- expects config keys to be written in kebab case (such as `my-field`) and the
associated field names are written in camel case (such as `myField`);
- allows unknown keys;
- uses the default values when a key is missing.

All of these assumptions can be overridden by putting an implicit
`ProductHint` - an object that "hints" PureConfig on how to best derive
converters for products in scope.

### Field mappings

In case the naming convention you use in your configuration files differs from
the default one, PureConfig allows you to define proper mappings. A mapping
between different naming conventions is done using a `ConfigFieldMapping`
object, with which one can construct a `ProductHint`. The `ConfigFieldMapping`
trait has a single `apply` method that maps field names in Scala objects to
field names in the source configuration file. For instance, here's a contrived
example where the configuration file has all keys in upper case and we're
loading it into a type whose fields are all in lower case:

```scala
case class SampleConf(foo: Int, bar: String)

implicit val productHint = ProductHint[SampleConf](new ConfigFieldMapping {
  def apply(fieldName: String) = fieldName.toUpperCase
})

val conf = parseString("""{
  FOO = 2
  BAR = "two"
}""")

loadConfig[SampleConf](conf)
// returns Success(SampleConf(2, "two"))
```

PureConfig provides a way to create a `ConfigFieldMapping` by defining the
naming conventions of the fields in the Scala object and in the configuration
file. Some of the most used naming conventions are supported directly in the
library:

* [`CamelCase`](https://en.wikipedia.org/wiki/Camel_case): `camelCase`, `useMorePureconfig`
* [`SnakeCase`](https://en.wikipedia.org/wiki/Snake_case): `snake_case`, `use_more_pureconfig`
* [`KebabCase`](http://wiki.c2.com/?KebabCase): `kebab-case`, `use-more-pureconfig`
* [`PascalCase`](https://en.wikipedia.org/wiki/PascalCase): `PascalCase`, `UseMorePureconfig`

You can use the `apply` method of `ConfigFieldMapping` that accepts the two
naming conventions (for the fields in the Scala object and for the fields in the
configuration file, respectively). A common use case is to have both your field
names and your configuration files in `camelCase`. In order to support it, you
can make sure the following implicit is in scope before loading or writing
configuration files:

```scala
implicit def hint[T] = ProductHint[T](ConfigFieldMapping(CamelCase, CamelCase))
```

### Default field values

If a case class has a default argument and the underlying configuration is
missing a value for that field, then by default PureConfig will happily
create an instance of the class, loading the other values from the
configuration:

```scala
import scala.concurrent.duration._

case class Holiday(where: String = "last resort", howLong: Duration = 7 days)

// Defaulting `where`
loadConfig[Holiday](parseString("""{ how-long: 21 days }"""))
// returns Success(Holiday("last resort", 21 days))

// Defaulting `howLong`
loadConfig[Holiday](parseString("""{ where: Zürich }"""))
// returns Success(Holiday("Zürich", 7 days))

// Defaulting both arguments
loadConfig[Holiday](parseString("""{}"""))
// returns Success(Holiday("last resort", 7 days))

// Specifying both arguments
loadConfig[Holiday](parseString("""{ where: Texas, how-long: 3 hours }"""))
// returns Success(Holiday("Texas", 3 hours))
```

A `ProductHint` can make the conversion fail if a key is missing from the
config regardless of whether a default value exists or not:

```scala
implicit val hint = ProductHint[Holiday](useDefaultArgs = false)

loadConfig[Holiday](parseString("""{ how-long: 21 days }"""))
// returns Failure(KeyNotFoundException("where"))
```

### Unknown keys

By default, PureConfig ignores keys in the config that do not map to any
case class field, leading to potential bugs due to misspellings:

```scala
loadConfig[Holiday](parseString("""{ wher: Texas, how-long: 21 days }"""))
// returns Success(Holiday("last resort", 21 days))
```

With a `ProductHint`, one can tell the converter to fail if an unknown key is
found:

```scala
implicit val hint = ProductHint[Holiday](allowUnknownKeys = false)

loadConfig[Holiday](parseString("""{ wher: Texas, how-long: 21 days }"""))
// returns Failure(UnknownKeyException("wher"))
```


## Override behaviour for sealed families

In order for PureConfig to disambiguate between different options of a sealed
family of case classes, it must read and write additional information in
configurations. By default it uses the additional field `type`, encoding the
concrete class represented in the configuration:

```scala
sealed trait AnimalConf
case class DogConf(age: Int) extends AnimalConf
case class BirdConf(canFly: Boolean) extends AnimalConf

loadConfig[AnimalConf](parseString("""{ type: "dogconf", age: 4 }"""))
// returns Success(DogConf(4))
```

For sealed families, PureConfig provides a way to customize the conversion
without replacing the default `ConfigConvert`. By putting in scope an instance
of `CoproductHint` for that sealed family, we can customize how the
disambiguation is made. For example, if `type` clashes with one of the fields
of a case class option, we can use another field:

```scala
implicit val animalConfHint = new FieldCoproductHint[AnimalConf]("kind")
loadConfig[AnimalConf](parseString("""{ kind: "dogconf", age: 4 }"""))
// returns Success(DogConf(4))
```

`FieldCoproductHint` can also be adapted to write class names in a different
way:

```scala
implicit val animalConfHint = new FieldCoproductHint[AnimalConf]("type") {
  override def fieldValue(name: String) = name.dropRight("Conf".length)
}
loadConfig[AnimalConf](parseString("""{ type: "Bird", canFly: true }"""))
// returns Success(BirdConf(true))
```

With a `CoproductHint` you can even opt not to use any extra field at all. For
example, if you encode enumerations using sealed traits, you can just write the
name of the class:

```scala
import com.typesafe.config.{ConfigFactory,ConfigValue}
import pureconfig.syntax._
import scala.util.Success

sealed trait Season
case object Spring extends Season
case object Summer extends Season
case object Autumn extends Season
case object Winter extends Season

implicit val seasonHint = new CoproductHint[Season] {

  // Reads a config for Season (`cv`).
  // - If `name` is the name of the concrete season `cv` refers to, returns
  //   `Success(Some(conf))`, where `conf` is the config for the concrete class
  //   (in this case, an empty object).
  // - If `name` is not the name of the class for `cv`, returns
  //   `Success(None)`.
  // - If `cv` is an invalid config for Season (in this case, if it isn't a
  //   string), returns a `Failure`.
  def from(cv: ConfigValue, name: String) = cv.to[String].map { strConf =>
    if(strConf == name) Some(ConfigFactory.empty.root) else None
  }

  // Writes a config for a Season. `cv` is a config for the concrete season
  // `name` (in this case, `cv` is always an empty object).
  def to(cv: ConfigValue, name: String) = Success(name.toConfig)

  // If `from` returns a `Failure` for a concrete class, should we try other
  // concrete classes?
  def tryNextOnFail(name: String) = false
}

case class MyConf(list: List[Season])
loadConfig[MyConf](parseString("""list = [Spring, Summer, Autumn, Winter]"""))
// returns Success(MyConf(List(Spring, Summer, Autumn, Winter)))
```


## Handling missing keys

The default behavior of `ConfigConvert`s that are derived in PureConfig is to
raise a `KeyNotFoundException` when a required key is missing. The only
exception is the `Option[_]` type, which is read as `None` when a key is
missing:

```scala
case class Foo(a: Int)
case class FooOpt(a: Option[Int])

ConfigFactory.empty.to[Foo]
// returns Failure(KeyNotFoundException("a"))

ConfigFactory.empty.to[FooOpt]
// returns Success(FooOpt(None))
```

However, if you want to allow your custom `ConfigConvert`s to handle missing
keys, you can extend the `AllowMissingKey` trait. For `ConfigConvert`s extending
`AllowMissingKey`, a missing key will issue a call to the `from` method of the
available `ConfigConvert` for that type with a `null` value:

```scala
import com.typesafe.config.ConfigRenderOptions

implicit val cc = new ConfigConvert[Int] with AllowMissingKey {
  override def from(config: ConfigValue): Try[Int] =
    if (config == null) Success(42) else Try(config.render(ConfigRenderOptions.concise).toInt)

  override def to(t: Int): ConfigValue = ConfigValueFactory.fromAnyRef(t)
}

ConfigFactory.empty.to[Foo]
// returns Success(Foo(42))
```


## Example

In the [example directory](https://github.com/melrief/pureconfig/tree/master/example/src/main/scala/pureconfig/example)
there is an example of usage of PureConfig. In the example, the idea is to load a configuration for a directory
watcher service. The configuration file
(a real one is available [here](https://github.com/melrief/pureconfig/blob/master/example/src/main/resources/application.conf))
for this program will look like:

```
dirwatch.path="/path/to/observe"
dirwatch.filter="*"
dirwatch.email.host=host_of_email_service
dirwatch.email.port=port_of_email_service
dirwatch.email.message="Dirwatch new path found report"
dirwatch.email.recipients=["recipient1,recipient2"]
dirwatch.email.sender="sender"
```

To load it, we define some classes that have proper fields and names:

```scala
import java.nio.file.Path

case class EmailConfig(host: String, port: Int, message: String, recipients: Set[String], sender: String)
case class DirWatchConfig(path: Path, filter: String, email: EmailConfig)
case class Config(dirwatch: DirWatchConfig)
```

The use of `Path` gives us a chance to use a custom converter:

```scala
import pureconfig._

import java.nio.file.Paths
import scala.util.Try

implicit val deriveStringConvertForPath = ConfigConvert.fromString[Path](s => Try(Paths.get(s)))
```

And then we load the configuration:

```scala
val config = loadConfig[Config].get // loadConfig returns a Try
```

And that's it.

You can then use the configuration as you want:

```scala
println("dirwatch.path: " + config.dirwatch.path)
println("dirwatch.filter: " + config.dirwatch.filter)
println("dirwatch.email.host: " + config.dirwatch.email.host)
println("dirwatch.email.port: " + config.dirwatch.email.port)
println("dirwatch.email.message: " + config.dirwatch.email.message)
println("dirwatch.email.recipients: " + config.dirwatch.email.recipients)
println("dirwatch.email.sender: " + config.dirwatch.email.sender)
```

It's also possible to operate directly on `Config` and `ConfigValue` types
of [Typesafe Config][typesafe-config] with the implicit helpers provided in the
`pureconfig.syntax` package:

```scala
import com.typesafe.config.ConfigFactory
import pureconfig.syntax._

val config = ConfigFactory.load.to[Config].get
println("The loaded configuration is: " + config.toString)
```

## Whence the config files?

By default, PureConfig `loadConfig` methods load all resources in the classpath named:

- `application.conf`,
- `application.json`,
- `application.properties`, and
- `reference.conf`.

The various `loadConfig` methods defer to [Typesafe Config][typesafe-config]'s
[`ConfigFactory`](https://typesafehub.github.io/config/latest/api/com/typesafe/config/ConfigFactory.html) to
select where to load the config files from. Typesafe Config has [well-documented rules for configuration
loading](https://github.com/typesafehub/config#standard-behavior) which we'll not repeat. Please see Typesafe
Config's documentation for a full telling of the subtleties. If you need greater control over how config
files are loaded, refer to `ConfigFactory` options.

Alternatively, PureConfig also provides a `loadConfigFromFiles` method, which builds a configuration from
an explicit list of files. Files earlier in the list have greater precedence than later ones. Each file can
include a partial configuration as long as the whole list produces a complete configuration. For an example,
see the test of `loadConfigFromFiles` in
[`PureconfSuite.scala`](https://github.com/melrief/pureconfig/blob/master/core/src/test/scala/pureconfig/PureconfSuite.scala).

Because PureConfig uses Typesafe Config to load configuration, it supports reading files in [HOCON](https://github.com/typesafehub/config/blob/master/HOCON.md#hocon-human-optimized-config-object-notation), JSON, and Java `.properties` formats. HOCON is a delightful superset of both JSON and `.properties` that is highly recommended. As an added bonus it supports [advanced features](https://github.com/typesafehub/config/blob/master/README.md#features-of-hocon) like variable substitution and file sourcing.


## Contribute

PureConfig is a free library developed by several people around the world.
Contributions are welcomed and encouraged. If you want to contribute, we suggest to have a look at the
[available issues](https://github.com/melrief/pureconfig/issues) and to talk with
us on the [pureconfig gitter channel](https://gitter.im/melrief/pureconfig?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge).

PureConfig supports the [Typelevel](http://typelevel.org/) [code of conduct](http://typelevel.org/conduct.html) and wants all of its channels (Gitter, GitHub, etc.) to be
welcoming environments for everyone.


## License

[Mozilla Public License, version 2.0](https://github.com/melrief/pureconfig/blob/master/LICENSE)


## Special Thanks

To the [Shapeless](https://github.com/milessabin/shapeless) and to the [Typesafe Config](https://github.com/typesafehub/config)
developers.

[typesafe-config]: https://github.com/typesafehub/config
